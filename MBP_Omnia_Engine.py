# MBP OMNIA INFINITI + X\u2122 SYSTEM — THE LITIGATION SINGULARITY ENGINE
# Simplified background daemon that queues legal filings based on violation logs.

import os
import json
import threading
import time
import subprocess
from datetime import datetime
from pathlib import Path
from EPOCH_UNPACKER_ENGINE_v1 import run_gui as unpacker_gui

SCAN_INTERVAL_SECONDS = 1800  # 30 minutes
F_DRIVE_PATH = "F:/"
TASK_QUEUE_PATH = "F:/MBP_TASKS/task_queue.json"
VIOLATION_LOG_PATH = "F:/MBP_LOGS/opposition_violations_log.json"
AUTO_DOC_OUTPUT_PATH = "F:/LegalResults/AutoGenerated/"
MCR_RULE_MAP = "F:/MBP_CORE/MCR/mcr_map.json"
SCAO_FORM_MAP = "F:/MBP_CORE/FORMS/scao_form_index.json"
GUI_EXECUTABLE_PATH = "F:/MBP_GUI/gui.exe"
LOG_PATH = "F:/MBP_LOGS/background_loop.log"


def load_json(path: str):
    if not os.path.exists(path):
        return [] if path.endswith(".json") else {}
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)


def save_json(path: str, data):
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2)


def dispatch_task(task):
    handler = f"F:/MBP_MODULES/{task['motion_type'].lower()}_handler.py"
    if os.path.exists(handler):
        try:
            subprocess.Popen(["python", handler], shell=False)
        except Exception as exc:
            print(f"[DISPATCH ERROR] {exc}")
    else:
        print(f"[DISPATCH] No handler for {task['motion_type']}")


def is_valid_motion_type(motion: str) -> bool:
    form_index = load_json(SCAO_FORM_MAP)
    rule_index = load_json(MCR_RULE_MAP)
    return motion in form_index and motion in rule_index


def scan_for_new_violations():
    print("[SCAN] Evaluating violation logs and queuing tasks")
    violations = load_json(VIOLATION_LOG_PATH)
    task_queue = load_json(TASK_QUEUE_PATH)
    now = datetime.now().isoformat()

    trigger_motion_types = [
        "TRO",
        "Affidavit",
        "VerifiedComplaint",
        "CanonViolationReport",
        "\u00a71983CivilRightsClaim",
        "RICOAction",
        "EmergencyInjunction",
        "MotionToCompel",
        "MotionToDisqualifyJudge",
        "SupervisoryAppeal",
    ]

    if len(violations) > 500:
        global SCAN_INTERVAL_SECONDS
        SCAN_INTERVAL_SECONDS = 300

    for motion in trigger_motion_types:
        if not is_valid_motion_type(motion):
            continue
        task = {
            "type": "GenerateMotion",
            "motion_type": motion,
            "timestamp": now,
            "source": "OMNIA_BackgroundDaemon",
            "status": "queued",
            "link": VIOLATION_LOG_PATH,
        }
        task_queue.append(task)
        dispatch_task(task)
        with open(LOG_PATH, "a", encoding="utf-8") as log:
            log.write(f"{now} — {motion} queued\n")

    save_json(TASK_QUEUE_PATH, task_queue)

    if os.path.exists(GUI_EXECUTABLE_PATH):
        try:
            subprocess.Popen([GUI_EXECUTABLE_PATH], shell=False)
        except Exception as e:
            print(f"[GUI ERROR] {e}")


def background_loop():
    print("[OMNIA ENGINE] Background daemon running")
    while True:
        scan_for_new_violations()
        time.sleep(SCAN_INTERVAL_SECONDS)


if __name__ == "__main__":
    os.makedirs(Path(TASK_QUEUE_PATH).parent, exist_ok=True)
    os.makedirs(Path(VIOLATION_LOG_PATH).parent, exist_ok=True)
    os.makedirs(AUTO_DOC_OUTPUT_PATH, exist_ok=True)
    for core in ["BENCHBOOKS", "MCR", "FORMS", "CANON", "EVIDENCE", "JUDGES", "TRANSCRIPTS"]:
        os.makedirs(f"F:/MBP_CORE/{core}", exist_ok=True)
    os.makedirs("F:/MBP_MODULES", exist_ok=True)
    os.makedirs("F:/MBP_LOGS", exist_ok=True)

    thread = threading.Thread(target=background_loop, daemon=True)
    thread.start()
    unpacker_gui()
    thread.join()
